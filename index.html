<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pesquisa de Decretos</title>

  <style>
    body{font-family:Arial, sans-serif; margin:40px; line-height:1.4}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    input{width:520px; max-width:100%; padding:10px; font-size:16px}
    button{padding:10px 14px; font-size:16px; cursor:pointer}
    .box{margin-top:12px; border:1px solid #ccc; padding:12px}
    .ok{background:#f6ffed; border-color:#b7eb8f}
    .bad{background:#fff1f0; border-color:#ffa39e}
    .muted{color:#666; font-size:12px}
    .card{border:1px solid #999; padding:14px; margin-top:18px}
    .pill{display:inline-block; border:1px solid #ccc; padding:2px 8px; border-radius:999px; font-size:12px; margin-right:6px}
    mark{background:yellow; font-weight:bold}
    pre{white-space:pre-wrap; word-wrap:break-word; background:#f7f7f7; border:1px solid #e5e5e5; padding:12px; max-height:420px; overflow:auto}
  </style>

  <script src="libs/pdf.min.js"></script>
</head>
<body>

<h2>Pesquisa de Decretos</h2>

<div class="row">
  <input id="q" placeholder="Digite imóvel, ocupação, endereço... (aceita erros e variações)" />
  <button id="btnIndex">Indexar decretos</button>
  <button id="btnSearch" disabled>Pesquisar</button>
</div>

<div id="status" class="box ok">Clique em <b>Indexar decretos</b>.</div>
<div class="muted" style="margin-top:8px">
  Dica: com 1 palavra, o site tenta encontrar a palavra mais parecida no texto (mesmo com erro). Com várias palavras, ele aceita palavras a mais/menos e ranqueia por “melhor encaixe”.
</div>

<div id="results"></div>

<script>
/* ================= CONFIGURAÇÃO ================= */
pdfjsLib.GlobalWorkerOptions.workerSrc = "libs/pdf.worker.min.js";

const DECRETO_FILES = [
  "decreto_159.pdf",
  "decreto_201.pdf",
  "decreto_213.pdf",
  "decreto_250.pdf",
  "decreto_265.pdf",
  "decreto_275.pdf",
  "decreto_310.pdf",
  "decreto_332.pdf",
  "decreto_338.pdf",
  "decreto_348.pdf",
  "decreto_392.pdf",
  "decreto_425.pdf",
  "decreto_464.pdf",
  "decreto_482.pdf",
  "decreto_507.pdf",
  "decreto_561.pdf",
  "decreto_576.pdf",
  "decreto_680.pdf"
];

/* ================= UI/ESTADO ================= */
const statusBox = document.getElementById("status");
const results = document.getElementById("results");
const btnIndex = document.getElementById("btnIndex");
const btnSearch = document.getElementById("btnSearch");
const q = document.getElementById("q");

let decrees = [];
let indexed = false;

function setOk(msg){ statusBox.className="box ok"; statusBox.innerHTML = msg; }
function setBad(msg){ statusBox.className="box bad"; statusBox.innerHTML = msg; }

/* ================= UTILITÁRIOS ================= */
function escapeHtml(s){
  return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

// remove acentos, baixa, normaliza espaços
function norm(s){
  return (s||"")
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

function tokenize(s){
  // palavras/nums, sem acentos (já normalizado)
  const t = norm(s);
  return t.split(/[^a-z0-9]+/i).filter(w => w.length > 0);
}

// Levenshtein (distância de edição)
function levenshtein(a, b){
  if(a === b) return 0;
  const al = a.length, bl = b.length;
  if(al === 0) return bl;
  if(bl === 0) return al;

  // Otimização: array de tamanho menor
  let prev = new Array(bl + 1);
  let cur  = new Array(bl + 1);
  for(let j=0; j<=bl; j++) prev[j] = j;

  for(let i=1; i<=al; i++){
    cur[0] = i;
    const ca = a.charCodeAt(i-1);
    for(let j=1; j<=bl; j++){
      const cost = (ca === b.charCodeAt(j-1)) ? 0 : 1;
      cur[j] = Math.min(
        prev[j] + 1,        // delete
        cur[j-1] + 1,       // insert
        prev[j-1] + cost    // replace
      );
    }
    [prev, cur] = [cur, prev];
  }
  return prev[bl];
}

// define tolerância por tamanho de palavra
function maxEdits(word){
  const n = word.length;
  if(n <= 3) return 0;      // muito curto: só exato
  if(n <= 5) return 1;
  if(n <= 8) return 2;
  return 3;
}

// highlight exato + fuzzy (palavras aproximadas encontradas)
function highlightFuzzy(originalText, query, matchedMap){
  // Primeiro destaca ocorrências exatas da query “crua”
  let out = escapeHtml(originalText);

  // Destaque exato (case-insensitive) da query inteira
  const qRaw = query.trim();
  if(qRaw.length >= 2){
    const safe = qRaw.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const re = new RegExp(safe, "gi");
    out = out.replace(re, m => `<mark>${escapeHtml(m)}</mark>`);
  }

  // Destaque das palavras que foram “casadas” (fuzzy)
  // matchedMap: {token -> bestWordInText}
  const wordsToMark = new Set(Object.values(matchedMap || {}).filter(Boolean));
  for(const w of wordsToMark){
    if(!w) continue;
    // marca a palavra como aparece “sem acento” é difícil; então marca pelo valor original aproximado:
    // para ser robusto, marca a versão sem acento também não dá via regex simples.
    // Aqui marcamos a palavra “normal” (já sem acento) caso exista no texto também.
    // Se não existir, o destaque exato acima já ajuda.
    const safeW = w.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const reW = new RegExp(`\\b${safeW}\\b`, "gi");
    out = out.replace(reW, m => `<mark>${escapeHtml(m)}</mark>`);
  }

  return out;
}

/* ================= EXTRAÇÃO PDF ================= */
async function extractTextFromPdf(url){
  const loadingTask = pdfjsLib.getDocument(url);
  const pdf = await loadingTask.promise;

  const pages = [];
  let fullText = "";

  for(let p=1; p<=pdf.numPages; p++){
    const page = await pdf.getPage(p);
    const textContent = await page.getTextContent();
    const strings = textContent.items.map(it => it.str).filter(Boolean);
    const pageText = strings.join(" ").replace(/\s+/g," ").trim();
    pages.push({ page: p, text: pageText });
    fullText += pageText + "\n\n";
  }

  return { pages, fullText: fullText.trim() };
}

function guessTitle(text, fallback){
  const m = (text||"").match(/DECRETO\s+N[º°]?\s*(\d+)/i);
  return m ? `Decreto nº ${m[1]}` : fallback;
}

/* ================= INDEXAÇÃO DE PALAVRAS ================= */
// Cria um set de palavras únicas do decreto (normalizadas) + lista (para percorrer)
function buildWordIndex(fullText){
  const t = norm(fullText);
  const words = t.split(/[^a-z0-9]+/i).filter(w => w.length > 0);

  // reduzir: só palavras >= 3 para fuzzy (e manter pequenas no set para exato)
  const uniq = new Set(words);
  const list = Array.from(uniq);

  return {
    set: uniq,
    list: list
  };
}

/* ================= BUSCA (EXATA + APROXIMADA) ================= */
function scoreDecree(decree, query){
  const qTokens = tokenize(query);
  if(qTokens.length === 0) return { ok:false, score:0, matchedMap:{} , exact:false };

  const textNorm = decree.fullTextNorm; // já normalizado
  const wordsSet = decree.wordIndex.set;
  const wordsList = decree.wordIndex.list;

  // 1) match exato do texto normalizado (toda a frase)
  const qNorm = norm(query);
  const exactPhrase = qNorm.length >= 2 && textNorm.includes(qNorm);

  // 2) matching por tokens (aceita palavras a mais/menos)
  let matched = 0;
  let totalWeight = 0;
  let matchedWeight = 0;
  const matchedMap = {};

  // Se tiver só 1 token, tenta achar a melhor palavra parecida e “encaixar”
  const single = (qTokens.length === 1);
  const tokenList = single ? qTokens : qTokens.filter(t => t.length >= 2);

  for(const tok of tokenList){
    const wTok = tok.length >= 6 ? 2 : 1; // peso: palavras maiores valem mais
    totalWeight += wTok;

    // exato por palavra
    if(wordsSet.has(tok)){
      matched++;
      matchedWeight += wTok;
      matchedMap[tok] = tok;
      continue;
    }

    // fuzzy: achar melhor palavra do decreto
    const maxD = maxEdits(tok);
    if(maxD === 0) continue;

    let bestWord = null;
    let bestDist = Infinity;

    // Otimização: só compara com palavras com tamanho próximo
    const minLen = Math.max(1, tok.length - maxD);
    const maxLen = tok.length + maxD;

    for(const w of wordsList){
      if(w.length < minLen || w.length > maxLen) continue;
      const d = levenshtein(tok, w);
      if(d < bestDist){
        bestDist = d;
        bestWord = w;
        if(d === 1) break; // bom o suficiente, corta cedo
      }
    }

    if(bestWord && bestDist <= maxD){
      matched++;
      matchedWeight += wTok * (1 - (bestDist / (maxD + 1))); // quanto mais perto, melhor
      matchedMap[tok] = bestWord;
    }
  }

  // Fração de match (aceita “a mais/menos”)
  const ratio = totalWeight > 0 ? (matchedWeight / totalWeight) : 0;

  // Critérios:
  // - Frase exata OU
  // - 1 palavra: precisa casar ao menos 1 (fuzzy ou exato) com ratio bom
  // - várias palavras: pelo menos 1 token casado e ratio mínimo
  let ok = false;

  if(exactPhrase) ok = true;
  else if(single) ok = (matched >= 1 && ratio >= 0.35);
  else ok = (matched >= 1 && ratio >= 0.45);

  // score final: base no ratio + bônus de frase exata
  const score = (ratio * 100) + (exactPhrase ? 25 : 0);

  return { ok, score, matchedMap, exact: exactPhrase };
}

function findPagesApprox(pages, matchedWords){
  // marca páginas onde aparece alguma palavra casada (normalizada)
  const needles = Array.from(new Set(Object.values(matchedWords || {}).filter(Boolean)));
  if(needles.length === 0) return [];

  const hit = [];
  for(const p of pages){
    const pn = norm(p.text);
    for(const w of needles){
      if(w && pn.includes(w)){
        hit.push(p.page);
        break;
      }
    }
  }
  return hit;
}

function renderResult(d, query, scored){
  const hitPages = scored.exact
    ? (function(){
        // para frase exata, páginas por frase normalizada
        const qn = norm(query);
        const hits = [];
        for(const p of d.pages){
          if(norm(p.text).includes(qn)) hits.push(p.page);
        }
        return hits;
      })()
    : findPagesApprox(d.pages, scored.matchedMap);

  const pagesHtml = hitPages.length
    ? hitPages.map(n => `<span class="pill">p. ${n}</span>`).join(" ")
    : `<span class="pill">sem página</span>`;

  // mostra como o fuzzy casou os termos (para confiança do usuário)
  const pairs = Object.entries(scored.matchedMap || {});
  const explain = pairs.length
    ? `<div class="muted">Casamento aproximado: ${pairs.map(([a,b]) => `<b>${escapeHtml(a)}</b> → ${escapeHtml(b)}`).join(" | ")}</div>`
    : `<div class="muted">Correspondência exata.</div>`;

  return `
    <div class="card">
      <b>${escapeHtml(d.title)}</b>
      <span class="muted"> (pontuação: ${scored.score.toFixed(1)})</span>
      <div style="margin:6px 0 10px 0">${pagesHtml}</div>
      ${explain}
      <pre>${highlightFuzzy(d.fullText, query, scored.matchedMap)}</pre>
    </div>
  `;
}

/* ================= EVENTOS ================= */
btnIndex.addEventListener("click", async () => {
  decrees = [];
  indexed = false;
  results.innerHTML = "";
  btnSearch.disabled = true;

  try{
    for(let i=0; i<DECRETO_FILES.length; i++){
      const file = DECRETO_FILES[i];
      const url = `decretos/${file}`;
      setOk(`Indexando ${i+1}/${DECRETO_FILES.length}: <b>${file}</b>`);

      const data = await extractTextFromPdf(url);

      const fullTextNorm = norm(data.fullText);
      const wordIndex = buildWordIndex(data.fullText);

      decrees.push({
        file,
        title: guessTitle(data.fullText, file),
        pages: data.pages,
        fullText: data.fullText,
        fullTextNorm,
        wordIndex
      });
    }

    indexed = true;
    btnSearch.disabled = false;
    setOk(`Indexação concluída ✅ ${DECRETO_FILES.length} decretos carregados.`);
  }catch(e){
    setBad(`Erro ao indexar.<br><b>${escapeHtml(e.message || String(e))}</b>`);
  }
});

btnSearch.addEventListener("click", () => {
  if(!indexed){
    setBad("Indexe os decretos primeiro.");
    return;
  }

  const query = q.value.trim();
  results.innerHTML = "";

  if(!query){
    setBad("Digite um termo para pesquisar.");
    return;
  }

  // score em todos e filtra os “ok”
  const scored = decrees
    .map(d => ({ d, s: scoreDecree(d, query) }))
    .filter(x => x.s.ok)
    .sort((a,b) => b.s.score - a.s.score);

  setOk(`Resultados: <b>${scored.length}</b> decreto(s) para “${escapeHtml(query)}” (aproximado).`);

  results.innerHTML = scored.length
    ? scored.map(x => renderResult(x.d, query, x.s)).join("")
    : `<div class="card">Nenhum resultado aproximado encontrado.</div>`;
});

q.addEventListener("keydown", e => { if(e.key === "Enter") btnSearch.click(); });
</script>

</body>
</html>
